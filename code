# Flask app for 3d model stuff with a nice ui using tailwind
# gotta install these: pip install flask numpy trimesh matplotlib pillow rembg

import numpy as np       # array 
import trimesh            # for the 3d mesh creation
import matplotlib.pyplot as plt          # to draw the 3d model
from mpl_toolkits.mplot3d import Axes3D             # 3d plotting helper
from flask import Flask, request, send_file        # web materials
import uuid                                   # unique ids for files
import os                                  # for file operations
import base64                              # encode images
from io import BytesIO                     # handle image bytes
from PIL import Image                    # image processing
from rembg import remove                       # bg removal
import time                                 # for delaying cleanup
import threading                                 # background cleanup

app = Flask(__name__)

# keep track of files to delete later
to_cleanup = []

# cleanup function - waits a bit before deleting files
def cleanup_later(paths, wait=30):  
    print(f"waiting {wait}s before cleanup: {paths}")
    time.sleep(wait)
    for p in paths:
        if os.path.exists(p):
            print(f"deleting {p}...")
            os.remove(p)
    to_cleanup.remove(paths)

# process an uploaded image into a 3d model
def img_to_3d(img_path):
    if not os.path.exists(img_path):
        raise ValueError("uh oh, image not found at " + img_path)
    if not img_path.lower().endswith(('.jpg', '.jpeg', '.png')):
        raise ValueError("only jpg and png allowed, sorry!")
    
    print("loading img:", img_path)
    img = Image.open(img_path)
    
    print("removing bg...")
    img_no_bg = remove(img)
    
    arr = np.array(img_no_bg)
    print("image shape:", arr.shape) # debug
    
    # check if it's RGBA or not
    if arr.shape[2] == 4:
        mask = arr[:,:,3] > 0 # alpha channel
    else:
        mask = arr[:,:,0] > 0
        print("no alpha channel, using first channel instead")
    
    pts = []
    print("making point cloud...")
    for y in range(mask.shape[0]):
        for x in range(mask.shape[1]):
            if mask[y][x]:
                pts.append([x, y, 0]) 
                pts.append([x, y, 0.1]) 
    
    pts = np.array(pts)
    print(f"got {len(pts)} points")
    
    if len(pts) > 3: # need at least 4 points for a mesh
        print("building mesh...")
        mesh = trimesh.convex.convex_hull(pts)
        mesh.apply_scale(0.01) # scale down so it fits nicely
        return mesh
    else:
        raise ValueError("not enough points for a mesh - try a better image!")

# turn text prompt into a 3d model
def text_to_3d(prompt):
    print("got prompt:", prompt)
    prompt = prompt.lower()
    
    # simple mapping for now
    if "car" in prompt:
        print("making a car (box shape)...")
        mesh = trimesh.creation.box(extents=[2, 1, 0.5])
    elif "cube" in prompt:
        print("making a cube...")
        mesh = trimesh.creation.box(extents=[1,1,1])
    elif "sphere" in prompt:
        print("making a sphere...")
        mesh = trimesh.creation.icosphere(subdivisions=2, radius=0.5)
    else:
        raise ValueError("only car, cube, or sphere prompts work rn")
    
    return mesh

# render and save the 3d model
def render_and_save(mesh, out_path, preview_path, user="sachin11"):
    # avoid overwriting files
    base, ext = os.path.splitext(out_path)
    i = 1
    while os.path.exists(out_path):
        out_path = f"{base}_{i}{ext}"
        i += 1
    
    print(f"saving model to {out_path}")
    with open(out_path, 'w') as f:
        f.write(f"# Generated by {user}\n") # add a header
        mesh.export(f, file_type='obj')
    
    print("rendering with matplotlib...")
    verts = mesh.vertices
    faces = mesh.faces
    
    # set up the plot
    fig = plt.figure(figsize=(6.4, 4.8)) # decent size
    ax = fig.add_subplot(111, projection='3d')
    
    # draw the mesh
    ax.plot_trisurf(
        verts[:,0], verts[:,1], verts[:,2],
        triangles=faces, color='gray', edgecolor='black', linewidth=0.5
    )
    
    # make sure the plot looks nice
    max_range = np.array([
        verts[:,0].max() - verts[:,0].min(),
        verts[:,1].max() - verts[:,1].min(),
        verts[:,2].max() - verts[:,2].min()
    ]).max() / 2.0
    mid_x = (verts[:,0].max() + verts[:,0].min()) / 2
    mid_y = (verts[:,1].max() + verts[:,1].min()) / 2
    mid_z = (verts[:,2].max() + verts[:,2].min()) / 2
    ax.set_xlim(mid_x - max_range, mid_x + max_range)
    ax.set_ylim(mid_y - max_range, mid_y + max_range)
    ax.set_zlim(mid_z - max_range, mid_z + max_range)
    
    ax.set_xlabel('X') # label axes
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.view_init(elev=30, azim=45) # nice angle
    
    # save to buffer for base64
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    img_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')
    
    # save to file too
    print(f"saving preview to {preview_path}")
    plt.savefig(preview_path, format='png', bbox_inches='tight')
    plt.close(fig) # cleanup
    
    return out_path, preview_path, img_base64

# main page with the form
@app.route('/')
def home():
    return """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>3D Model Generator</title>
        <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body class="bg-gray-100 min-h-screen flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-md">
            <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">3D Model Generator</h1>
            <p class="text-gray-600 mb-4 text-center">User ID: sachin11</p>
            <form id="genForm" action="/generate" method="POST" enctype="multipart/form-data">
                <div class="mb-4">
                    <label for="imgInput" class="block text-gray-700 font-medium mb-2">Upload an image (.jpg or .png):</label>
                    <input type="file" id="imgInput" name="image" accept="image/jpeg,image/png" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="mb-6">
                    <label for="txtInput" class="block text-gray-700 font-medium mb-2">Or enter your text prompt:</label>
                    <input type="text" id="txtInput" name="text" placeholder="Enter prompt (e.g., 'car', 'cube', 'sphere')" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <button type="submit" id="genBtn" class="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 transition-colors duration-300">Generate</button>
            </form>
        </div>

        <script>
            // quick js to show loading state
            document.getElementById('genForm').addEventListener('submit', function() {
                let btn = document.getElementById('genBtn');
                btn.textContent = 'Generating...';
                btn.disabled = true;
            });
        </script>
    </body>
    </html>
    """

# handle form submission and generate the model
@app.route('/generate', methods=['POST'])
def generate_model():
    print("form data:", request.form) # debug
    print("files:", request.files)
    
    # set up output dir
    out_dir = 'static/output'
    os.makedirs(out_dir, exist_ok=True)
    
    # unique id for files
    file_id = str(uuid.uuid4())
    model_path = os.path.join(out_dir, f'model_{file_id}.obj')
    img_path = os.path.join(out_dir, f'preview_{file_id}.png')
    
    # handle image or text input
    if 'image' in request.files and request.files['image'].filename:
        img_file = request.files['image']
        temp_path = os.path.join(out_dir, f'input_{file_id}.png')
        img_file.save(temp_path)
        try:
            mesh = img_to_3d(temp_path)
        finally:
            if os.path.exists(temp_path):
                os.remove(temp_path) # cleanup temp file
    elif request.form.get('text'):
        text = request.form['text']
        if not text.strip():
            return "need a non-empty text prompt (like 'car', 'cube', 'sphere')", 400
        mesh = text_to_3d(text)
    else:
        return "gimme either an image or a text prompt!", 400
    
    # render and save the model
    model_path, img_path, img_base64 = render_and_save(mesh, model_path, img_path)
    
    # schedule cleanup
    paths = [model_path, img_path]
    to_cleanup.append(paths)
    threading.Thread(target=cleanup_later, args=(paths,)).start()
    
    # results page
    return f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Generated 3D Model</title>
        <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body class="bg-gray-100 min-h-screen flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-lg w-full max-w-2xl">
            <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Generated 3D Model</h1>
            <p class="text-gray-600 mb-4 text-center">Generated by User ID: sachin11</p>
            <div class="mb-6">
                <p class="text-gray-700 font-medium mb-2 text-center">Preview:</p>
                <img src="data:image/png;base64,{img_base64}" alt="3D Model Preview" class="w-full rounded-md shadow-sm">
            </div>
            <div class="flex justify-center space-x-4">
                <a href="/download/{img_path}" download class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-300">Download Preview (.png)</a>
                <a href="/download/{model_path}" download class="bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 transition-colors duration-300">Download 3D Model (.obj)</a>
            </div>
            <div class="mt-6 text-center">
                <a href="/" class="text-blue-600 hover:underline">Generate Another</a>
            </div>
        </div>
    </body>
    </html>
    """

# download route
@app.route('/download/<path:filepath>')
def download(filepath):
    if not os.path.exists(filepath):
        return "file gone, sorry! try generating again", 404
    return send_file(filepath, as_attachment=True)

# TODO: maybe add some error handling here
if __name__ == "__main__":
    app.run(debug=True, host='0.0.0.0', port=5000, threaded=False)
